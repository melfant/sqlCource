<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Основы SQL - презентация</title>
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- custom user theme -->
    <link rel="stylesheet" href="lib/css/bootstrap.css">
    <link rel="stylesheet" href="css/theme/tables.css">
    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides">

            <section>
                <h2>Презентация тут</h2>
                <img src="http://qrcoder.ru/code/?https%3A%2F%2Fmelfant.github.io%2FsqlCourse%2F&10&0" width="410" height="410"
                    border="0" title="QR код">
                <p>https://melfant.github.io/sqlCourse/</p>
            </section>


            <section>
                <section>
                    <h1>Вспомним,</h1>
                    <h3>Чему мы научились в дистанционной части</h3>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <p>Это мы умеем</p>
                    <pre><code>
select distinct 
    col1, col2 as column2, col3 column3, col4 [column 4], 
    case 
        when datediff(month, col5, current_timestamp) < 5 then 1
        else 0
    end as col5_modified,
    len(col6) as len_col_6,
    col7 + '_' + isnull(col8, '') as col7_and_col8,
    cast('24' as int) as twenty_four,
    *
from table
where col1 <= 0 or col2 like '%pattern%' and col3 is null
order by col4 desc, col2 asc, col1</code></pre>
                    <h4>&darr;</h4>
                    <aside class=notes>
                        Что знакомого в запросе? Что происходит в каждом столбце?
                    </aside>
                </section>
                <section>
                    <p>Каков логический порядок выполнения запроса?</p>
                    <pre><code  class="sql">
select distinct 
    case 
        when datediff(month, col5, current_timestamp) < 5 then 1
        else 0
    end as col5_modified
from table
where col1 <= 0 or col2 like '%pattern%' and col3 is null
order by col5_modified desc</code></pre>
                    <pre class="fragment"><code>1. from table</code></pre>
                    <pre class="fragment"><code>2. where --какой порядок?</code></pre>
                    <pre class="fragment"><code>3. case ... as col5_modified</code></pre>
                    <pre class="fragment"><code>4. distinct</code></pre>
                    <pre class="fragment"><code>5. order by col5_modified desc</code></pre>
                    <pre class="fragment"><code>6. select</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>ПЕРЕД ТЕМ КАК НАЧАТЬ</h1>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h2>ВОПРОС</h2>
                    <br/>
                    <h5 class="fragment">Какие сложности могут возникнуть у человека, читающего чужой код?</h5>
                </section>
                <section>
                    <pre>
                        <code class="sql">SELECT SourceSystemRecordNumber,DealDate,
CASE WHEN MaturityDate IS NULL THEN 0 else DATEDIFF(month, ValueDate , CURRENT_TIMESTAMP)end IntPayments,
DATEADD(MONTH, DATEDIFF(month, ValueDate , CURRENT_TIMESTAMP),DealDate) LastPayment
FROM [dwh].[vDeal] WHERE BusinessBlockCode = 'SmallBusiness'
ORDER BY CASE WHEN MaturityDate IS NULL THEN 0 else DATEDIFF(month, ValueDate , CURRENT_TIMESTAMP) END</code>
                    </pre>
                    <img src="pictures/elfLanguage.jpg" class="fragment">
                </section>
                <section>
                    <h2>Как справиться с этими сложностями?</h2>
                    <br/>
                    <h5 class="fragment">Договориться об единых правилах написания кода!</h5>
                </section>
            </section>
            <section>
                <section>
                    <h1>Базовые правила написания кода</h1>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h4>ОФОРМЛЕНИЕ КОДА</h4>
                    <pre>
                        <code class="sql">select distinct
    ProductCode,
    case
        when BusinessBlockCode = 'SmallBusiness'
            then 'Малый бизнес'
        else 'Другое'
    end Description,
    datediff(day, DealDate, MaturityDate) as Term,
    *
from dwh.vDeal
where ProductCode = 'L_CORP_DEPO_T'</code>
                    </pre>
                    <pre class="fragment"><code>-- Ветвления кода отделены отступами</code></pre>
                    <pre class="fragment"><code>-- Отступы везде одинаковые (например, один tab)</code></pre>
                    <pre class="fragment"><code>-- Все операторы написаны в одном регистре</code></pre>
                    <pre class="fragment"><code>-- Аргументы одинаково отделены от предыдущего значения</code></pre>
                </section>
                <section>
                    <h4>СТИЛЬ ИМЕНОВАНИЯ</h4>
                    <p>По имени объекта должно быть понятно, что в нем хранится</p>
                    <div class="row">
                        <div class="col-xs-5">
                            <pre><code class="sql">select
    v_d,
    m_d,
    an
from c_d</code></pre>
                        </div>
                        <div class="col-xs-2" align="center"><p>vs</p></div>
                        <div class="col-xs-5">
                            <pre><code class="sql">select
    ValueDate,
    MaturityDate,
    AccountNumber
from CorpDeposits</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <h4>СТИЛЬ ИМЕНОВАНИЯ</h4>
                    <p>В базе данных стоит придерживаться одного стиля, зависящего от договоренности команды</p>
                    <div class="row">
                        <div class="col-xs-5">
                            <div class="row"><pre><code class="sql">select
    reportDate
from myTable</code></pre></div>
                            <div class="row"><pre><code class="sql">select
    REPORT_DATE
from MY_TABLE</code></pre></div>
                        </div>
                        <div class="col-xs-2"></div>
                        <div class="col-xs-5">
                            <div class="row"><pre><code class="sql">select
    ReportDate
from MyTable</code></pre></div>
                            <div class="row"><pre><code class="sql">select
    rprt_dt
from m_tbl</code></pre></div>
                        </div>
                    </div>
                </section>
            </section>
            <section>
                <h1>Запросы к нескольким таблицам</h1>
                <aside class=notes>
                    До сих пор мы работали только с единственной таблицей, но, данные, описывающие какую-то либо сущность, обычно разбиты на
                    несколько таблиц и хранятся в в них. Этот процесс известен как нормализация
                </aside>
            </section>
            <section>
                <p>Данные, описывающие объект, обычно хранятся во множестве таблиц</p>
                <br>
                <p>
                    <strong>Нормализация</strong> - это процесс преобразования данных, устраняющий:
                    <ul>
                        <li>Избыточность</li>
                        <li>Логические ошибки</li>
                        <li>Аномалии обновления</li>
                    </ul>
                </p>
                <aside class=notes>
                    Нормализация, как правило, нацелена на то, чтобы хранились только первичные факты (а не факты, выводимые из других)
                </aside>
            </section>
            <section>
                <section>
                    <p>Попробуем нормализовать таблицу</p>
                    <table class="table-small">
                        <tbody>
                            <tr>
                                <th>FullName</th>
                                <td>Скопинцев Сергей Юрьевич</td>
                            </tr>
                            <tr>
                                <th>BirthDate</th>
                                <td>1984-09-23</td>
                            </tr>
                            <tr>
                                <th>HireDate</th>
                                <td>2010-04-01</td>
                            </tr>
                            <tr>
                                <th>HireAge</th>
                                <td>24</td>
                            </tr>
                            <tr>
                                <th>Department</th>
                                <td>Казначейство/ОБАС ALM</td>
                            </tr>
                            <tr>
                                <th>Salary</th>
                                <td>890</td>
                            </tr>
                            <tr>
                                <th>BossFullName</th>
                                <td>Нейштадт Игорь Анатольевич</td>
                            </tr>
                            <tr>
                                <th>SalaryDiffWithBoss</th>
                                <td>1000</td>
                            </tr>
                        </tbody>
                    </table>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h4>Идеи</h4>
                    <ul>
                        <li class=fragment>Разбить ФИО на три поля</li>
                        <li class=fragment>Не хранить HireAge</li>
                        <li class=fragment>Нужна таблица департаментов</li>
                        <li class=fragment>Сотрудник должен иметь id</li>
                        <li class=fragment>Босс должен быть указан ссылкой</li>
                        <li class=fragment>Не хранить разницу зарплат</li>
                    </ul>
                    <h4 class=fragment>&darr;</h4>
                </section>
                <section>
                    <div class="row">
                        <div class="col-xs-6">
                            <table class="table-small">
                                <tr>
                                    <td><span class="fragment">PK</span></td>
                                    <th>EmployeeId</th>
                                    <td>1</td>
                                    <td>2</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>FirstName</th>
                                    <td>Сергей</td>
                                    <td>Игорь</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>MiddleName</th>
                                    <td>Юрьевич</td>
                                    <td>Анатольевич</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>LastName</th>
                                    <td>Скопинцев</td>
                                    <td>Нейштадт</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>HireDate</th>
                                    <td>2014-04-01</td>
                                    <td>NULL</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>BirthDate</th>
                                    <td>1984-09-23</td>
                                    <td>NULL</td>
                                </tr>
                                <tr>
                                    <td><span class="fragment">FK</span></td>
                                    <th>DepartmentId</th>
                                    <td>101</td>
                                    <td>101</td>
                                </tr>
                                <tr>
                                    <td><span class="fragment">FK</span></td>
                                    <th>BoossId</th>
                                    <td>2</td>
                                    <td>NULL</td>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>Salary</th>
                                    <td>890</td>
                                    <td>1890</td>
                                </tr>
                            </table>
                        </div>
                        <div class="col-xs-6">
                            <table class="table-small">
                                <tr>
                                    <td><span class="fragment">PK</span></td>
                                    <th>DepartmentId</th>
                                    <td>101</td>
                                </tr>
                                <tr>
                                    <td><span class="fragment">UK</span></td>
                                    <th>DepartmentName</th>
                                    <td>ОБАС ALM</td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </section>
                <aside class="notes">
                    Давайте рассмотрим таблицу, которую мог создать один из менеджеров. Какие вы могли бы сделать предложения по улучшению структуры
                    таблицы? 5 Минут, работаем в группах, каждая группа делаем доклад 2 минуты
                </aside>
            </section>
            <section>
                <p><strong>PK</strong> - primary key, столбец (или комбинация), которое уникальным образом определяет запись
                    в таблице. Бизнес-смысла нет.</p>
                <p class=fragment><strong>UK</strong> - Unique key, уникальная комбинация столбцов. Как правило, имеет бизнес-смысл.</p>
                <p class=fragment><strong>FK</strong> - Foreign key, ограничение, гарантирующее, что значения в столбце будут только из множества
                    значений определенного PK</p>
            </section>
            <section>
                <section>
                    <h3>Кстати, представления!</h3>
                    <p class="fragment" align="left">Кроме таблиц, в базах бывают представления</p>
                    <div class="fragment">
                        <p align="left">Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.</p>
                        <p align="left">Представления иногда называют «виртуальными таблицами».</p>
                    </div>
                </section>
                <section>
                    <h3>Пример представления</h3>
                    <pre><code class="sql">create view [dwh].[vCounterparty]
as
select
    cntp.Name,
    ct.CounterpartyTypeName,
    cr.CountryName,
    cntp.FoundationYear
from dwh.Counterparty cntp
	 left join dwh.DimCounterpartyType ct
        on ct.CounterpartyTypeId = cntp.CounterpartyTypeId
	 left join dwh.DimCountry cr
        on cr.CountryId = cntp.CountryId</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h1>Учебная БД</h1>
                    <h1>&darr;</h1>
                </section>
                <section data-background-image="pictures/dw-schema.png" data-background-size="100%"></section>

            </section>
            <section>
                <h1>ОПЕРАЦИИ НАД МНОЖЕСТВАМИ</h1>
            </section>
            <section>
                <section>
                    <h4>ОБЪЕДИНЕНИЕ ТАБЛИЦ</h4>
                    <p>Для объединения нескольких запросов используется оператор <mark>UNION [ALL]</mark></p>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <p>Допустим, мы хотим вывести всех клиентов CIB из 2 источников. Сравните результат двух запросов:</p>
                    <div class="row">
                        <div class="col-xs-6"><pre><code data-noescape class="sql">select
    SourceSystemRecordNumber,
    CounterpartyName
from mbk.vMBKDeals
where BusinessBlockCode = 'CIB'

<mark>union all</mark>

select
    SourceSystemRecordNumber,
    Name
from dwh.vDeal
where BusinessBlockCode = 'CIB'
order by SourceSystemRecordNumber</code></pre></div>
                        <div class="col-xs-6"><pre><code data-trim data-noescape class="sql">select
    SourceSystemRecordNumber,
    CounterpartyName
from mbk.vMBKDeals
where BusinessBlockCode = 'CIB'

<mark>union</mark>

select
    SourceSystemRecordNumber,
    Name
from dwh.vDeal
where BusinessBlockCode = 'CIB'
order by SourceSystemRecordNumber</code></pre></div>
                    </div>
                </section>
                <section>
                    <p>Если требуется вывести в результирующий набор все строки каждого запроса вместе с повторами, необходимо использовать <mark>UNION ALL</mark>.</p>
                    <p class="fragment">Для вывода только уникальных строк каждого запроса используется <mark>UNION</mark>.</p>
                </section>
            </section>
            <section>
                <section>
                    <h4>ПЕРЕСЕЧЕНИЕ И РАЗНОСТЬ</h4>
                    <p>Для выполнения операции пересечения или разности результатов запросов используется соответственно <mark>INTERSECT [ALL]</mark> и <mark>EXCEPT [ALL]</mark>.</p>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <div class="row">
                        <pre><code data-trim data-noescape class="sql">select
    SourceSystemRecordNumber,
    CounterpartyName
from mbk.vMBKDeals
where BusinessBlockCode = 'CIB'

<mark>intersect</mark>

select
    SourceSystemRecordNumber,
    Name
from dwh.vDeal
where BusinessBlockCode = 'CIB'
order by SourceSystemRecordNumber</code></pre></div>
                    <div class="row"><p align="left">Запрос выводит только те сделки, которые присутствуют в обоих таблицах. Если поменять таблицы местами, результат не изменится. Заголовок всегда берется из первой таблицы.</p></div>
                </section>
                <section>
                    <div class="row">
                        <pre><code data-trim data-noescape class="sql">select
    SourceSystemRecordNumber,
    CounterpartyName
from mbk.vMBKDeals
where BusinessBlockCode = 'CIB'

<mark>except</mark>

select
    SourceSystemRecordNumber,
    Name
from dwh.vDeal
where BusinessBlockCode = 'CIB'
order by SourceSystemRecordNumber</code></pre></div>
                    <div class="row"><p align="left">Запрос выводит только те сделки, которые есть в первой таблице, но отсутствуют во второй. Если поменять таблицы местами, результат изменится.</p></div>
                </section>
            </section>
            <section>
                <section>
                    <h1>НЕМНОГО ПРАКТИКИ</h1>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h4>UNION/EXCEPT/INTERSECT – ЗАДАЧА 1</h4>
                    <p align="left">Напишите запрос, выбирающий
                    <ul>
                        <li>дату валютирования, сумму, валюту и имя контрагента</li>
                    </ul>
                    </p>
                    <p align="left">для сделок, присутствующих в CORPORATE_LIABILITIES.CA и в dwh.vDeal на 2018-04-30. Вывести данные требуется без дубликатов.</p>
                    <p align="left">Обратите внимание на разное обозначение рублей в таблицах. Используйте <mark>CASE</mark> или <mark>REPLACE</mark>.</p>
                </section>
                <section>
                    <h4>UNION/EXCEPT/INTERSECT – ЗАДАЧА 1, решение</h4>
                    <pre><code class="sql">select
	VALUE_DATE,
	Amount,
	case
		when CCY = 'RUR' then 'RUB'
		else CCY
	end as CCY,
	COUNTERPARTY_NAME
from CORPORATE_LIABILITIES.ca

union all

select
	ValueDate,
	CurrentNominal,
	CurrencyCode,
	Name
from dwh.vDeal d
where d.BookValueDate = '2018-04-30'</code></pre>
                </section>
                <section>
                    <h4>UNION/EXCEPT/INTERSECT– ЗАДАЧА 2</h4>
                    <p align="left">Напишите запрос, выбирающий </p>
                    <ul>
                        <li>дату валютирования (вывести как ValueDate)</li>
                        <li>сумму (вывести как Amount)</li>
                        <li>валюту  (вывести как CCY)</li>
                        <li>имя контрагента (вывести как Name)</li>
                    </ul>
                    <p align="left">для сделок, присутствующих как в представлении dwh.vDeal, так и в источнике данных CORPORATE_LIABILITIES.CA. Вывести данные требуется без дубликатов.</p>
                </section>
                <section>
                    <h4>UNION/EXCEPT/INTERSECT– ЗАДАЧА 2, решение</h4>
                    <pre><code class="sql">select
	VALUE_DATE as ValueDate,
	AMOUNT as Amount,
	CCY,
	COUNTERPARTY_NAME as Name
from CORPORATE_LIABILITIES.ca

intersect

select
	ValueDate,
	CurrentNominal as Amount,
	CurrencyCode as CCY,
	Name
from dwh.vDeal</code></pre></section>
            </section>
            <section>
                <h3>Соединение таблиц</h3>
                <p>Для соединения двух и более таблиц используется оператор
                    <mark>JOIN</mark>
                </p>
                <p class=fragment>* Похож на ВПР (vlookup)</p>
            </section>
            <section>
                <div class="row">
                    <div class="col-xs-6">
                        <table class="table-small">
                            <caption>EnglishNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                        <br>
                        <table class="table-small">
                            <caption>FrenchNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                    </div>
                    <div class="col-xs-6">
                        <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f on 
    e.NumberId = 
        f.NumberId</code></pre>
                    </div>
                </div>
            </section>
            <section>
                <section>
                    <h3>Как работает JOIN?</h3>
                    <div class="row">
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f on 
    e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                            <img class="invert" src="pictures/joinmapping-inner-join.png" alt="join mapping">

                        </div>
                        <div class="col-xs-6">
                            <p>Для каждой пары строк вычисляется предикат соединения</p>
                            <p>Если предикат
                                <mark>TRUE</mark> - пара строк попадает в выборку</p>

                        </div>
                    </div>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <p>INNER JOIN == JOIN</p>
                    <img class="invert" src="pictures/join-schema.png" alt="join-schema">
                </section>
            </section>
            <section>
                <h4>Порядок выполнения запроса</h4>

                <div class="row">
                    <div class="col-xs-6">
                        <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f on 
    e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                    </div>
                    <div class="col-xs-6">
                        <pre class="fragment"><code>1. from EnglishNumbers as e</code></pre>
                        <pre class="fragment"><code>2. join FrenchNumbers f on ...</code></pre>
                        <pre class="fragment"><code>3. where ...</code></pre>
                        <pre class="fragment"><code>4. evaluate columns</code></pre>
                        <pre class="fragment"><code>5. select</code></pre>
                    </div>
                </div>
            </section>
            <section>
                <h3>Вопрос</h3>
                <p class="fragment">В чем разница?</p>
                <div class="row fragment">
                    <div class="col-xs-6">
                        <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId and
    e.NumberId > 3</code></pre>
                    </div>
                    <div class="col-xs-6">
                        <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId
where e.NumberId > 3</code></pre>
                    </div>
                </div>
            </section>
            <section>
                <p>В одном запросе можно присоединять несколько таблиц (и даже ту же самую таблицу)</p>
                <pre><code>select *
from table1 t1
join table2 t2 on t1.id = t2.id
join table3 t3 on t3.id = t2.id
join table1 t1_par on t1.parent_id = t1_par.id
....</code></pre>
                <p class="fragment">Операции соединения логически выполняются слева-направо и в объединении участвует всегда 2 множества. Результирующее
                    множество является входящим слева для следующей операции соединения.
                </p>
            </section>
            <section>
                <section>
                    <h1>Немного практики</h1>
                    <h1>&darr;</h1>
                </section>
                <section>
                    <h3>Join - Задача 1</h3>
                    <p>Напишите запрос, выбирающий для каждого контрагента (таблица dwh.Counterparty) название его типа (таблица dwh.DimCounterpartyType, столбец
                        CounterpartyTypeName).
                    </p>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 1, решение</h3>
                    <pre><code class="sql">select
	c.*,
	dct.CounterpartyTypename
from dwh.Counterparty c
	join dwh.DimCounterpartyType dct
		on dct.CounterpartyTypeId = c.CounterpartyTypeId</code></pre>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 2</h3>
                    <p>Модифицируйте запрос из предыдущей задачи таким образом, чтобы выбирались только контрагенты - юр. лица.
                    </p>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 2, решение</h3>
                    <pre><code class="sql">select
	c.*,
	dct.CounterpartyTypename
from dwh.Counterparty c
	join dwh.DimCounterpartyType dct
		on dct.CounterpartyTypeId = c.CounterpartyTypeId
where dct.CounterpartyTypename = 'Юридические лица'</code></pre>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 3</h3>
                    <p>Добавьте к предыдущему запросу еще название страны контрагента (таблица dwh.DimCountry, столбец CountryName).</p>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 3, решение</h3>
                    <pre><code class="sql">select
	c.*,
	dct.CounterpartyTypename,
	dc.CountryName
from dwh.Counterparty c
	join dwh.DimCounterpartyType dct
		on dct.CounterpartyTypeId = c.CounterpartyTypeId
	join dwh.DimCountry dc
		on dc.CountryId = c.CountryId
where dct.CounterpartyTypename = 'Юридические лица'</code></pre>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <h3>Join - Задача 4*</h3>
                    <p>Из таблицы dwh.Deal выберите сделки за апрель (BookValueDate = '2018-04-30') у которых с марта (BookValueDate = '2018-03-31') уменьшился остаток основного долга (поле CurrentNominal).
                    </p>
                </section>
                <section>
                    <h3>Join - Задача 4*, решение</h3>
                    <pre><code class="sql">
select
	d1.*,
	d2.CurrentNominal as PreviousMonthCurrentNominal
from dwh.deal d1
	join dwh.deal d2
		on d2.SourceSystemId = d1.SourceSystemId
		and d2.SourceSystemRecordNumber = d1.SourceSystemRecordNumber
		and d2.BookValueDate = '2018-03-31'
		and d2.CurrentNominal > d1.CurrentNominal
where d1.BookValueDate = '2018-04-30'</code></pre>
                    <h4>&darr;</h4>
                </section>
            </section>
            <section>
                <p>Как оставить строку Two - 2 из EnglishNumbers в выборке?</p>
                <div class="row">
                    <div class="col-xs-6">
                        <img class="invert fragment fade-out" data-fragment-index="0" src="pictures/joinmapping-left-join-empty.png" alt="join mapping">
                        <img style="position:absolute;left:12px;" class="invert fragment fade-in" data-fragment-index="0" src="pictures/joinmapping-left-join.png"
                            alt="join mapping"></div>
                    <div class="col-xs-6">
                        <table class="table-small">
                            <caption>EnglishNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                        <br>
                        <table class="table-small">
                            <caption>FrenchNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="row">
                    <div class="col fragment" data-fragment-index="0">
                        <p>Idea!!</p>
                        <h2>LEFT JOIN</h2>
                    </div>
                </div>


            </section>
            <section>
                <h3>left join</h3>
                <div class="row">
                    <div class="col-xs-6">
                        <table class="table-small">
                            <caption>EnglishNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                        <br>
                        <table class="table-small">
                            <caption>FrenchNumbers</caption>
                            <tr>
                                <td>PK</td>
                                <th>NumberId</th>
                            </tr>
                            <tr>
                                <td></td>
                                <th>NumberName</th>
                            </tr>
                        </table>
                    </div>
                    <div class="col-xs-6">
                        <pre><code data-noescape>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
<mark>left</mark> join FrenchNumbers f on 
    e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                    </div>
                </div>
            </section>

            <section>
                <section>
                    <h3>Как работает LEFT JOIN?</h3>
                    <div class="row">
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
join FrenchNumbers f on 
    e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                            <img class="invert" src="pictures/joinmapping-left-join.png" alt="join mapping"></div>
                        <div class="col-xs-6">
                            <p>Для каждой пары строк вычисляется предикат соединения</p>
                            <p>Если предикат
                                <mark>TRUE</mark> - пара строк попадает в выборку</p>
                            <mark>иначе,</mark>
                            строка Левой таблицы попадает в выборку, а вместо правой - подставляются NULL
                        </div>
                    </div>
                    <h4>&darr;</h4>
                </section>
                <section>
                    <p>LEFT OUTER JOIN == LEFT JOIN</p>
                    <img class="invert" src="pictures/left-join-schema.png" alt="left-join-schema">
                </section>
            </section>
            <section>
                <section>
                    <h3>Вопрос</h3>
                    <p class="fragment">В чем разница?</p>
                    <div class="row fragment">
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
left join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                        </div>
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from FrenchNumbers f
left join EnglishNumbers as e
    on e.NumberId = 
        f.NumberId
where f.NumberId > 0</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>Вопрос</h3>
                    <p class="fragment">В чем разница?</p>
                    <div class="row fragment">
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
left join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId and
    e.NumberId > 3</code></pre>
                        </div>
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
left join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId and
where e.NumberId > 3</code></pre>
                        </div>
                    </div>
                </section>
            </section>
            <section>
                <h4>Порядок выполнения запроса</h4>
                <div class="row">
                    <div class="col-xs-6">
                        <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
left join FrenchNumbers f 
    on e.NumberId = 
        f.NumberId
where e.NumberId > 0</code></pre>
                    </div>
                    <div class="col-xs-6">
                        <pre class="fragment"><code>1. from EnglishNumbers as e</code></pre>
                        <pre class="fragment"><code>2. left join FrenchNumbers f 
    on ...</code></pre>
                        <pre class="fragment"><code>3. where ...</code></pre>
                        <pre class="fragment"><code>4. evaluate columns</code></pre>
                        <pre class="fragment"><code>5. select</code></pre>
                    </div>
                </div>
            </section>
            <section>
                <p>join и left join можно комбинировать в одном запросе</p>
                <pre><code>select *
from table1 t1
left join table2 t2 on t1.id = t2.id
join table3 t3 on t3.id = t2.id
left join table1 t1_par on t1.parent_id = t1_par.id
....</code></pre>
                <p class="fragment">join-инструкции выполняются последовательно!</p>
            </section>
            <section>
                <section>
                    <h1>Немного практики</h1>
                    <h1>&darr;</h1>
                </section>
                <section>
                    <h3>Left JOIN - Задача 1</h3>
                    <p>Из представления dwh.vDeal для контрагента 'Важный Иван Иванович' (поле Name в dwh.Counterparty) выведите сделки за 2018-04-30. Добавьте к этим сделкам остатки за предыдущий месяц ('2018-03-31'), если такие существуют.</p>
                </section>
                <section>
                    <h3>Left JOIN - Задача 1, решение</h3>
                <pre><code>select
	d1.*,
	d2.CurrentNominal as PreviousMonthCurrentNominal
from dwh.vDeal d1
	left join dwh.vDeal d2
		on d2.BookValueDate = '2018-03-31'
		and d2.SourceSystemId = d1.SourceSystemId
		and d2.SourceSystemRecordNumber = d1.SourceSystemRecordNumber
where d1.BookValueDate = '2018-04-30'
	and d1.Name = 'Важный Иван Иванович'</code></pre>
                </section>
            </section>

            <section>
                <section>
                    <h3>RIGHT JOIN</h3>
                    <p>это тоже самое, что и LEFT JOIN, где таблицы поменяли местами</p>
                </section>
                <section>
                    <h4>Как переписать запрос с использованием right join?</h4>
                    <div class="row">
                        <div class="col-xs-6">
                            <pre><code>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from FrenchNumbers f 
left join EnglishNumbers as e
    on e.NumberId = 
        f.NumberId</code></pre>
                        </div>
                        <div class="col-xs-6 fragment">
                            <pre><code data-noescape>select 
    e.NumberName as EngNumber,
    f.NumberName as FreNumber,
    e.*,
    *
from EnglishNumbers as e
<mark>right</mark> join FrenchNumbers f
    on e.NumberId = 
        f.NumberId</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <img class="invert" src="pictures/joinmapping-right-join.png" alt="right-join">
                </section>
            </section>

            <section>
                <section>
                    <div class="row">
                        <div class="col-xs-12">
                            <p>Как оставить строки правой таблицы и строки левой таблицы в выборке?</p>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-xs-6">
                            <img class="invert" src="pictures/joinmapping-full-join.png" alt="join mapping">
                        </div>
                        <div class="col-xs-6">
                            <table class="table-small">
                                <caption>EnglishNumbers</caption>
                                <tr>
                                    <td>PK</td>
                                    <th>NumberId</th>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>NumberName</th>
                                </tr>
                            </table>
                            <br>
                            <table class="table-small">
                                <caption>FrenchNumbers</caption>
                                <tr>
                                    <td>PK</td>
                                    <th>NumberId</th>
                                </tr>
                                <tr>
                                    <td></td>
                                    <th>NumberName</th>
                                </tr>
                            </table>
                        </div>
                    </div>

                    <div class="row fragment " data-fragment-index="0">
                        <div class="col">
                            <p>Idea!!</p>
                            <h2>FULL JOIN</h2>
                        </div>
                    </div>
                </section>
                <section>
                    <p>FULL OUTER JOIN == FULL JOIN</p>
                    <img class="invert" src="pictures/full-join-schema.png" alt="left-join-schema">
                </section>
            </section>

            <section>
                <p>А как получить декартово произведение?</p>
                <div class="row">
                    <div class="col-xs-6">
                        <img class="invert" src="pictures/cross-join-schema.png" alt="cross join">
                    </div>
                    <div class="col-xs-6">
                        <pre class="fragment"><code>join ... on 1=1</code></pre>
                        <p class="fragment">CROSS JOIN !!!</p>
                        <pre class="fragment"><code>select *
from table1
cross join table2
...</code></pre>
                    </div>
                </div>


            </section>
            <section>
                <h3>JOIN - итоги</h3>
                <ol>
                    <li class="fragment">Внутренний (inner) join</li>
                    <li class="fragment">Внешний</li>
                    <ol>
                        <li class="fragment">left (outer) join</li>
                        <li class="fragment">full (outer) join</li>
                        <li class="fragment">right (outer) join</li>
                    </ol>
                    <li class="fragment">Декартово cross join</li>
                </ol>
            </section>

            <section>
                <h1>ПОДЗАПРОСЫ</h1>
            </section>
            <section>
                <section>
                    <h3>Самостоятельные скалярные подзапросы</h3>
                    <p>Запрос, возвращающий одно значение, может быть использован везде, где ожидается скалярное выражение</p>
                    <div class="row">
                        <div class="col-xs-6 fragment">
                            <pre><code>select
    CounterpartyTypeId
from dwh.DimCounterpartyType
where CounterpartyTypename
    = 'Банки'
 -- 1

select *
from dwh.Counterparty
where CounterpartyTypeId = 1</code></pre>
                        </div>
                        <div class="col-xs-6 fragment">
                            <pre><code>select *
from dwh.Counterparty
where CounterpartyTypeId =
(
select CounterpartyTypeId
from dwh.DimCounterpartyType
where CounterpartyTypename
    = 'Банки'
)</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <p>Если запрос вернет больше одного значения - ошибка</p>
                    <pre><code>select *
from dwh.Counterparty
where CounterpartyTypeId =
(
select CounterpartyTypeId
from dwh.DimCounterpartyType
where CounterpartyTypename like '%Банки%'
)
</code></pre>
                    <pre class="fragment sql-exception">Сообщение 512, уровень 16, состояние 1, строка 120
Subquery returned more than 1 value. This is not permitted when the subquery follows =, !=, <, <= , >, >= or when the subquery is used as an expression.
</pre>
                </section>
                <section>
                    <p>Если запрос вернет пустоту, то в выражение подставится NULL</p>
                    <pre><code>select *
from dwh.Counterparty
where
(
select CounterpartyTypeId
from dwh.DimCounterpartyType
where CounterpartyTypename = 'Counterparty Type'
) is null</code></pre>
                </section>
            </section>
            <section>
                <section>
                    <h3>Самостоятельный подзапрос, возвращающий столбец</h3>
                    <p>используется в предикате, когда хочется проверить, принадлежит ли значение списку</p>
                    <div class="row">
                        <div class="col-xs-6">
                            <pre><code>select *
from dwh.DimCountry
where CountryName in (
    'Россия',
    'США')</code></pre>
                            <pre class=fragment data-fragment-index="1"><code>select *
from dwh.DimCountry
where CountryName not in (
    'Россия',
    'США')
</code></pre>
                        </div>
                        <div class="col-xs-6 fragment" data-fragment-index="0">
                            <pre><code>select * 
from dwh.Counterparty
where CountryId in
(
select CountryId
from dwh.DimCountry
where CountryName in (
    'Россия',
    'США')
)
</code></pre>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>NULL vs IN</h3>
                    <p class=fragment>При выполнении операции
                        <mark>in</mark> происходит сравнение элемента слева с каждым элементом из подзапроса через равенство (=),
                        и
                        <mark>NULL</mark>
                        ведет себя как при операции =</p>
                </section>
            </section>
            <section>
                <section>
                    <h3>Закрепим знания</h3>
                    <p>&darr;</p>
                </section>
                <section>
                    <h4>Задача 1 - подзапрос</h4>
                    <p>Написать запрос, выбирающий всех контрагентов (все строки представления dwh.vCounterparty), у которых код страны +7 (таблица DimCountry).</p>
                </section>
                <section>
                    <h4>Задача 1 - подзапрос, решение</h4>
                <pre><Code class="sql">select *
from dwh.vCounterparty
where CountryName in (
	select
		countryName
	from dwh.DimCountry
	where PhoneCode = '+7'
)</Code></pre>
                </section>
                <section>
                    <h4>Задача 2 - подзапрос</h4>
                    <p>Написать запрос, выбирающий все бизнес-блоки, у которых родительским является блок CorporateBusiness. Необходимо вывести столбец BusinessBlockName и дополнительный столбец isMMB, который выводит 1, если это микро или малый бизнес, и 0 для всех остальных.</p>
                </section>
                <section>
                    <h4>Задача 2 - подзапрос, решение </h4>
                    <pre><code>select
	BusinessBlockName,
	1 as isMMB
from dwh.DimBusinessBlock
where ParentBusinessBlockId in (
	select
		BusinessBlockId
	from dwh.DimBusinessBlock
	where BusinessBlockCode = 'CorporateBusiness'
)</code></pre>
                </section>
            </section>

            <section>

                <h4>Коррелированные подзапросы</h4>
                <p>это такие подзапросы, в которых есть зависимость от внешнего запроса</p>
                <p></p>

            </section>
            <section>

                <p>Скалярный коррелированный подзапрос</p>
                <pre><code data-noescape>select  'BusinessBlock is ' + (
select bb.BusinessBlockName
from dwh.DimBusinessBlock bb
where bb.BusinessBlockId = <mark>m.BusinessBlockId</mark>
) as BBName,
*
from mbk.MBKDeals m</code></pre>
                <p class="fragment">Возвращает скаляр (одно значение)</p>
                <p class="fragment">Зависит от внешнего запроса</p>
                <p class="fragment"><i>Те же правила, что и для скалярного самостоятельного подзапроса</i></p>
            </section>

            <section>

                <h4>Коррелированный подзапрос, возвращающий столбец</h4>
                <pre><code data-noescape>select *
from dwh.vDeal vd
where ValueDate in (
select r.BookValueDate
from dwh.FxRate r
where r.CurrencyCode = <mark>vd.CurrencyCode</mark>
and r.FxRate > 63
)</code></pre>
                <p class="fragment">Все также, как и самостоятельном подзапросе, возвращающем столбец, за исключением зависимости от внешнего
                    запроса
                </p>
            </section>

            <section>

                <h4>Оператор exists</h4>
                <p class=fragment>используется в составе предиката, чтобы проверить, есть ли строки в подзапросе или нет</p>
                <pre class=fragment><code data-noescape>select *
from dwh.vDeal vd
where vd.ProductCode like 'A%' and exists
(
select *
 from dwh.AvgFtpScenario avg
where avg.CCY = <mark>vd.CurrencyCode</mark>
and avg.AvgRate > <mark>vd.CurrentNominalInterestRate</mark>
)</code></pre>
            </section>

            <section>
                <section>
                    <h3>Порешаем задачи</h3>
                    <p>&darr;</p>
                </section>
                <section>
                    <h4>Задача 1 - корелированный подзапрос</h4>
                    <p>Для каждого контрагента (dwh.Counterparty) вывести его имя и тип (CounterpartyTypename из dwh.DimCounterpartyType). Задачу решить
                        с помощью подзапроса.</p>
                </section>
                <section>
                    <h4>Задача 1 - корелированный подзапрос, решение</h4>
                    <pre><code class="sql">select
	c.Name,
	(	select
			CounterpartyTypename
		from dwh.DimCounterpartyType
		where CounterpartyTypeId = c.CounterpartyTypeId
	) as CounterpartyType
from dwh.Counterparty c</code></pre>
                </section>
                <section>
                    <h4>Задача 2 - корелированный подзапрос</h4>
                    <p>Написать запрос, выбирающий контрагентов (все столбцы из dwh.Counterparty), у которых есть сделки на 2018-04-30</p>
                </section>
                <section>
                    <h4>Задача 2 - корелированный подзапрос, решение</h4>
                    <pre><code class="sql">select
	*
from dwh.Counterparty
where CounterpartyId in (
	select distinct CounterpartyId
	from dwh.deal
	where BookValueDate = '2018-04-30'
)

-------------------------------------

select
	*
from dwh.Counterparty c
where exists (
	select top 1 *
	from dwh.deal
	where BookValueDate = '2018-04-30'
		and CounterpartyId = c.CounterpartyId
)</code></pre>
                </section>
                <section>
                    <h4>Задача 3 - корелированный подзапрос</h4>
                    <p>Вывести все сделки за 2018-04-30 (dwh.Deal), контрагенты по которым не являются юр. лицами</p>
                </section>
                <section>
                    <h4>Задача 3 - корелированный подзапрос, решение</h4>
                    <pre><code class="sql">select
	*
from dwh.Deal
where BookValueDate = '2018-04-30'
	and CounterpartyId not in (
		select CounterpartyId
		from dwh.Counterparty
		where CounterpartyTypeId = (
			select CounterpartyTypeId
			from dwh.DimCounterpartyType
			where CounterpartyTypename = 'Юридические лица'
		)
	)</code></pre>
                </section>
                <section>
                    <h4>Задача 4</h4>
                    <p>Для каждого контрагента вывести его ID, а также ID другого контрагента, который основан позже него (поле FoundationYear). Если таких контрагентов несолько, вывести минимальный ID</p>
                </section>
                <section>
                    <h4>Задача 4 - корелированный подзапрос, решение</h4>
                    <pre><code class="sql">select
	c.CounterpartyId,
	(	select top 1
			CounterpartyId
		from dwh.Counterparty
		where FoundationYear > c.FoundationYear
		order by FoundationYear
	) as OtherCounterpartyID

	, *
from dwh.Counterparty c</code></pre>
                </section>
            </section>
            <section>
                <h3>Табличные выражения</h3>
            </section>
            <section>
                <h4>Производные таблицы</h4>
                <p>Что такое табличное выражение?<br>Рассмотрим пример</p>
                <pre><code>select *
from 
(
    select *
    from dwh.Counterparty c
    where c.CounterpartyTypeId = 1
) as banks</code></pre>
                <ul>
                    <li class="fragment">Все столбцы табл. выражения должны иметь уникальные имена</li>
                    <li class="fragment">Табличное выражение не может содержать ORDER BY без TOP</li>
                </ul>
            </section>
            <section>
                <h4>Обобщенные табличные выражения</h4>
                <p>Common Table Expressions (CTE)</p>
                <pre><code>with bank as (
    select *
    from dwh.Counterparty c
    where c.CounterpartyTypeId = 1
)
select *
from bank</code></pre>
                <p class="fragment">* К CTE можно обращаться несколько раз в одном запросе</p>
                <p class="fragment">* Внутри CTE можно обращатся к предыдущему CTE</p>
            </section>



            <section>
                <h2>ГРУППОВЫЕ ЗАПРОСЫ</h2>
            </section>
            <section>
                <h4>Кому они нужны?</h4>
                <p class="fragment">Групповые запросы нужны для подсчета аггрегированных мер (сумм, средних и т.д.) в разрезе некоторых
                    групп
                </p>
                <pre class="fragment"><code class="sql">select count(*)
from dwh.Deal
where BookValueDate = '2018-04-30'

select CurrencyCode, count(*)
from dwh.Deal
where BookValueDate = '2018-04-30'
group by CurrencyCode</code></pre>
                <p class=fragment>Запрос становится групповым, если есть групповая функции или GROUP BY</p>
            </section>
            <section>
                <h4>Какие есть групповые функции?</h4>
                <pre><code class="sql">select count(*), -- количество строк в группе 
    count(column), -- количество непустых
    count(distinct column), -- количество уникальных
    sum(column), -- сумма
    max(column), -- максимум
    min(column), -- минимум
    avg(column) -- среднее
from tbl
group by other_column</code></pre>
                <p class="fragment">Групповые функции игнорируют NULL</p>
            </section>

            <section>
                <section>
                    <h3>Попробуем написать групповой запрос</h3>
                    <p>&darr;</p>
                </section>
                <section>
                    <h4>Задача 1 - group by</h4>
                    <p>Написать запрос, возвращающий количество контрагентов каждого типа. Столбец с количеством назвать cnt </p>
                </section>
                <section>
                    <h4>Задача 1 - group by, решение</h4>
                    <pre><code class="sql">select
	CounterpartyTypeName,
	count(*) as cnt
from dwh.vCounterparty
group by
	CounterpartyTypeName</code></pre>
                </section>
                <section>
                    <h4>Задача 2 - group by</h4>
                    <p>Написать запрос возвращающий всех контрагентов, у которых есть сделки, средний остаток по которым (за всю доступную историю) был бы более 1 млн. рублей. Учитывайте только рублевые депозиты.
                    </p>
                </section>
                <section>
                    <h4>Задача 2 - group by, решение</h4>
                    <pre><code class="sql">with avg_d as (
	select
		SourceSystemRecordNumber,

		avg(CurrentNominal) as AverageCurrentNominal
	from dwh.vDeal
	where CurrencyCode = 'RUB'
	group by
		SourceSystemRecordNumber
)

select
	*
from dwh.Counterparty c
where exists (
	select
		top 1 d1.*
	from dwh.Deal d1
	where d1.CounterpartyId = c.CounterpartyId
		and d1.SourceSystemRecordNumber in (
			select SourceSystemRecordNumber
			from avg_d
			where avg_d.AverageCurrentNominal > 1e6
		)
)</code></pre>
                </section>
                <section>
                    <h4>Задача 3 - group by</h4>
                    <p>Вывести 30% самых самых крупных договоров (в рублевом эквиваленте) на 2018-04-30 и их средний остаток основного долга (в рублях).</p>
                </section>
                <section>
                    <h4>Задача 3 - group by, решение</h4>
                    <pre><code class="sql">with d as (
	select
		d.*,
		d.CurrentNominal * case when d. CurrencyCode = 'RUB' then 1 else fx.FxRate end as CurrentNominalRub
	from dwh.Deal d
		left join dwh.FxRate fx
			on fx.BaseCurrencyCode = 'RUB'
			and fx.CurrencyCode = d.CurrencyCode
			and fx.BookValueDate = d.BookValueDate
),
avg_d as (
	select
		SourceSystemRecordNumber,
		avg(CurrentNominalRub) as AvgCurrentNominalRub
	from d
	group by
		SourceSystemRecordNumber
)

select top 30 percent
	*,
	ad.AvgCurrentNominalRub
from d
	left join avg_d ad
		on ad.SourceSystemRecordNumber = d.SourceSystemRecordNumber
where d.BookValueDate = '2018-04-30'</code></pre>
                </section>
            </section>

            <section>
                <h4>having</h4>
                <p>используется для фильтрации на групповом уровне</p>
                <pre class="fragment"><code class="sql">select CounterpartyId, count(*) as cnt
from dwh.Deal
where BookValueDate = '2018-04-30'
group by CounterpartyId
having count(*) > 3</code></pre>
                <p class="fragment">having применяется к группе, а не к строке</p>
                <p class="fragment">после having можно использовать только групповые столбцы и функции</p>
            </section>

            <section>
                <h4>Порядок исполнения запроса</h4>
                <div class="row">
                    <div class="col-xs-6">
                        <pre><code class="sql">select
CounterpartyId,
count(*) as cnt
from dwh.Deal
where BookValueDate = '2018-04-30'
group by CounterpartyId
having count(*) > 3</code></pre>
                    </div>
                    <div class="col-xs-6">
                        <pre class="fragment"><code>1. from ...</code></pre>
                        <pre class="fragment"><code>2. where ...</code></pre>
                        <pre class="fragment"><code>3. group by ...</code></pre>
                        <pre class="fragment"><code>4. having ...</code></pre>
                        <pre class="fragment"><code>5. evaluate columns ...</code></pre>
                        <pre class="fragment"><code>6. select ...</code></pre>
                    </div>
                </div>
            </section>
            <section>
                <h4>Задача - having</h4>
                <p>Написать запрос возвращающий всех контрагентов, у которых средний остаток по сделкам в рублевом эквиваленте за каждую дату (из имеющейся истории) был бы больше 2 млн. рублей.
                </p>
            </section>
            <section>
                <h4>Задача - having, решение</h4>
                <pre><code class="sql">with avg_d as (
	select
		d.BookValueDate,
		d.CounterpartyId,
		avg(d.CurrentNominal
			* case when d.CurrencyCode = 'RUB' then 1 else fx.FxRate end
		) as AvgCurrentNominalRub
	from dwh.Deal d
		left join dwh.FxRate fx
			on fx.BookValueDate = d.BookValueDate
			and fx.CurrencyCode = d.CurrencyCode
			and fx.BaseCurrencyCode = 'RUB'
	group by
		d.BookValueDate,
		d.CounterpartyId
),
--отметим клиентов, у которых средний остаток опускался ниже двух миллионов
avg_d_2 as (
	select
		d1.BookValueDate,
		d1.CounterpartyId,
		d2.CounterpartyId as ctp2

	from avg_d d1
		left join avg_d d2
			on d2.BookValueDate = d1.BookValueDate
			and d2.CounterpartyId = d1.CounterpartyId
			and d2.AvgCurrentNominalRub > 2e6
)

select
	*
from dwh.Counterparty
where
	--клиенты, у которых средний остаток хоть раз был больше двух млн.
	CounterpartyId in (select distinct CounterpartyId from avg_d where AvgCurrentNominalRub > 2e6)
	--и у которых средний остаток не опускался ниже двух миллионов
	and CounterpartyId not in	(	select distinct
										CounterpartyId
									from avg_d_2
									where ctp2 is null
								)</code></pre>
            </section>
            <!--section>
                <h1>Конец!</h1>
            </section-->
            <section>
                <h1>Продолжение следует!</h1>
            </section>

        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
            dependencies: [
                { src: 'plugin/markdown/marked.js' },
                { src: 'plugin/markdown/markdown.js' },
                { src: 'plugin/notes/notes.js', async: true },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
            ]
        });
        Reveal.configure({ slideNumber: true });
    </script>
</body>

</html>
